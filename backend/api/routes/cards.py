"""
cards.py â€” Proactive advisor card generation

POST   /api/cards/generate/{user_id}   â€” Generate AI proactive cards
GET    /api/cards/{user_id}            â€” Fetch stored cards (instant)
DELETE /api/cards/{user_id}            â€” Clear AI-generated cards
POST   /api/cards/ask/{user_id}        â€” User asks a question â†’ single card
POST   /api/cards/{card_id}/thread     â€” Follow-up thread on a card
PATCH  /api/cards/{card_id}/save       â€” Toggle saved state on a card
PATCH  /api/cards/{user_id}/reorder    â€” Persist drag-and-drop order
"""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import anthropic
import logging
import json
from datetime import datetime, timezone
from typing import List

from api.utils.supabase_client import get_supabase, get_user_by_id
from api.config import settings
from api.exceptions import UserNotFoundException

router = APIRouter()
logger = logging.getLogger(__name__)


def _lang_instruction(language: str) -> str:
    if language == "fr":
        return (
            "\n\nCRITICAL: You MUST respond entirely in French. "
            "Every text field â€” title, body, actions, label â€” must be in French. "
            "Do not use any English words."
        )
    return ""

# â”€â”€ Anthropic client singleton â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# FIX: Create once at module level instead of per-request to avoid
# repeated object allocation and connection overhead.
_anthropic_client: anthropic.Anthropic | None = None


def get_anthropic_client() -> anthropic.Anthropic:
    """Return the shared Anthropic client, initialising it on first use."""
    global _anthropic_client
    if _anthropic_client is None:
        _anthropic_client = anthropic.Anthropic(api_key=settings.ANTHROPIC_API_KEY)
    return _anthropic_client


# â”€â”€ Permanent category set â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CARD_CATEGORIES = [
    "deadlines",
    "degree",
    "courses",
    "grades",
    "planning",
    "opportunities",
]
CATEGORIES_PROMPT_LIST = "\n".join(f'  - "{c}"' for c in CARD_CATEGORIES)


# â”€â”€ Pydantic models â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class ThreadRequest(BaseModel):
    user_id: str
    message: str
    card_context: str
    language: str = "en"

class GenerateRequest(BaseModel):
    force: bool = False
    language: str = "en"

class AskRequest(BaseModel):
    user_id: str
    question: str
    language: str = "en"

class RetranslateRequest(BaseModel):
    language: str = "en"

class SaveRequest(BaseModel):
    is_saved: bool

class ReorderRequest(BaseModel):
    # List of {id, sort_order} pairs
    order: List[dict]


# â”€â”€ Supabase helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def fetch_student_context(user_id: str) -> dict:
    supabase = get_supabase()
    user = get_user_by_id(user_id)

    favorites = (supabase.table("favorites")
        .select("course_code, course_title, subject, catalog")
        .eq("user_id", user_id).order("created_at", desc=True).limit(30)
        .execute().data or [])

    completed = (supabase.table("completed_courses")
        .select("course_code, course_title, subject, catalog, term, year, grade, credits")
        .eq("user_id", user_id).order("year", desc=True).limit(50)
        .execute().data or [])

    current = (supabase.table("current_courses")
        .select("course_code, course_title, subject, catalog, credits")
        .eq("user_id", user_id).execute().data or [])

    today = datetime.now(timezone.utc).date().isoformat()
    calendar = (supabase.table("calendar_events")
        .select("title, date, time, type, description")
        .eq("user_id", user_id).gte("date", today)
        .order("date", desc=False).limit(20)
        .execute().data or [])

    return {"user": user, "favorites": favorites,
            "completed": completed, "current": current, "calendar": calendar}


def fetch_saved_cards(user_id: str) -> list:
    """Return all currently-saved cards for a user."""
    supabase = get_supabase()
    resp = (supabase.table("advisor_cards")
        .select("title, body, category")
        .eq("user_id", user_id)
        .eq("is_saved", True)
        .execute())
    return resp.data or []


def cards_are_fresh(user_id: str, max_age_hours: int = 12) -> bool:
    try:
        supabase = get_supabase()
        resp = (supabase.table("advisor_cards")
            .select("generated_at").eq("user_id", user_id).eq("source", "ai")
            .order("generated_at", desc=True).limit(1).execute())
        if not resp.data:
            return False
        generated_at = datetime.fromisoformat(
            resp.data[0]["generated_at"].replace("Z", "+00:00"))
        age_hours = (datetime.now(timezone.utc) - generated_at).total_seconds() / 3600
        return age_hours < max_age_hours
    except Exception:
        return False


def _sanitise_category(card: dict) -> str:
    cat = card.get("category", "planning")
    return cat if cat in CARD_CATEGORIES else "planning"


def save_cards(user_id: str, cards: list) -> None:
    """
    Replace AI-generated, non-saved cards.
    Saved cards and user-asked cards are never touched.
    New cards get sort_order starting after the highest existing sort_order
    so saved cards (which keep their order) naturally stay at the top.
    """
    supabase = get_supabase()

    # Delete only AI-generated cards that are NOT saved
    supabase.table("advisor_cards").delete() \
        .eq("user_id", user_id) \
        .eq("source", "ai") \
        .eq("is_saved", False) \
        .execute()

    if not cards:
        return

    # Find the current max sort_order so new cards go below saved ones
    existing = (supabase.table("advisor_cards")
        .select("sort_order")
        .eq("user_id", user_id)
        .order("sort_order", desc=True)
        .limit(1)
        .execute().data or [])
    base_order = (existing[0]["sort_order"] + 1) if existing else 0

    now = datetime.now(timezone.utc).isoformat()
    rows = [{
        "user_id": user_id,
        "card_type": card.get("type", "insight"),
        "icon": card.get("icon", "ðŸ’¡"),
        "label": card.get("label", "INSIGHT"),
        "title": card.get("title", ""),
        "body": card.get("body", ""),
        "actions": json.dumps(card.get("actions", [])),
        "priority": card.get("priority", i + 1),
        "sort_order": base_order + i,
        "category": _sanitise_category(card),
        "source": "ai",
        "is_saved": False,
        "expires_at": card.get("expires_at"),
        "generated_at": now,
    } for i, card in enumerate(cards)]
    supabase.table("advisor_cards").insert(rows).execute()


def insert_user_card(user_id: str, card: dict, question: str) -> dict:
    """Insert a single user-asked card at sort_order=0 (top of feed)."""
    supabase = get_supabase()
    row = {
        "user_id": user_id,
        "card_type": card.get("type", "insight"),
        "icon": card.get("icon", "ðŸ’¬"),
        "label": card.get("label", "YOUR QUESTION"),
        "title": card.get("title", question[:80]),
        "body": card.get("body", ""),
        "actions": json.dumps(card.get("actions", [])),
        "priority": 0,
        "sort_order": 0,
        "category": _sanitise_category(card),
        "source": "user",
        "is_saved": False,
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "user_question": question,   # store for retranslation
    }
    result = supabase.table("advisor_cards").insert(row).execute()
    inserted = result.data[0] if result.data else row
    if isinstance(inserted.get("actions"), str):
        inserted["actions"] = json.loads(inserted["actions"])
    return inserted


# â”€â”€ Prompt builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def build_rich_context(ctx: dict, saved_cards: list = None) -> str:
    user = ctx["user"]
    completed, current, favorites, calendar = (
        ctx["completed"], ctx["current"], ctx["favorites"], ctx["calendar"])

    # 1. Protection for completed course credits
    total_credits = sum(c.get("credits") or 3 for c in completed)
    
    # 2. FIX: The advanced standing credit calculation
    adv = user.get("advanced_standing") or []
    # Using 'or 0' handles cases where the key "credits" exists but the value is None
    adv_credits = sum((a.get("credits") or 0) for a in adv)
    
    adv_summary = ", ".join(
        f"{a['course_code']} ({a.get('credits') or 0} cr)" for a in adv
    ) or "None"

    def fmt_completed():
        return "\n".join(
            f"  - {c['course_code']} ({c.get('course_title','')}) | "
            f"Grade: {c.get('grade') or 'N/A'} | Term: {c.get('term','?')} {c.get('year','')}"
            for c in completed) or "  None recorded"

    def fmt_list(items, code_key="course_code", title_key="course_title"):
        return "\n".join(
            f"  - {i[code_key]} ({i.get(title_key,'')})" for i in items
        ) or "  None recorded"

    calendar_str = "\n".join(
        f"  - {e['date']}: {e['title']} [{e.get('type','personal')}]"
        + (f" â€” {e['description']}" if e.get('description') else "")
        for e in calendar) or "  No upcoming events"

    majors_str = user.get("major", "Undeclared")
    for m in (user.get("other_majors") or []):
        majors_str += f", {m}"
    minors_str = user.get("minor") or "None"
    for m in (user.get("other_minors") or []):
        minors_str += f", {m}"

    # Build saved-cards context so the AI doesn't duplicate them
    saved_section = ""
    if saved_cards:
        saved_lines = "\n".join(
            f"  - [{c.get('category','planning')}] {c['title']}: {c['body'][:120]}"
            for c in saved_cards
        )
        saved_section = f"""
SAVED CARDS (already pinned by the student â€” DO NOT regenerate cards covering the same topic or insight):
{saved_lines}
"""

    return f"""You are a proactive AI academic advisor for McGill University.
Analyse the student's profile and generate 8 high-value briefing cards.
{saved_section}
Today: {datetime.now(timezone.utc).date().isoformat()}

STUDENT PROFILE
  Name/email   : {user.get('username') or user.get('email', 'Student')}
  Faculty      : {user.get('faculty') or 'Not specified'}
  Major(s)     : {majors_str}
  Minor(s)     : {minors_str}
  Concentration: {user.get('concentration') or 'None'}
  Year         : U{user.get('year') or '?'}
  Credits done : {total_credits} (+ {adv_credits} advanced standing: {adv_summary})

COMPLETED COURSES
{fmt_completed()}

CURRENT COURSES
{fmt_list(current)}

SAVED/FAVOURITED COURSES
{fmt_list(favorites)}

UPCOMING CALENDAR EVENTS
{calendar_str}

INSTRUCTIONS
Generate exactly 8 cards as a JSON array. Each card must include:
  "type"     : one of "urgent" | "warning" | "insight" | "progress"
  "icon"     : single emoji
  "label"    : short ALL-CAPS label (â‰¤ 4 words)
  "title"    : concise headline (â‰¤ 12 words)
  "body"     : 1â€“3 sentence explanation with specific, actionable detail
  "actions"  : array of 2â€“3 short follow-up question strings
  "category" : one of:
{CATEGORIES_PROMPT_LIST}
  "priority" : integer 1â€“8 (1 = most important)

Return ONLY the JSON array â€” no markdown, no commentary."""


# â”€â”€ Routes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@router.get("/{user_id}", response_model=dict)
async def get_cards(user_id: str):
    try:
        get_user_by_id(user_id)
        supabase = get_supabase()
        resp = (supabase.table("advisor_cards")
            .select("*")
            .eq("user_id", user_id)
            .order("sort_order", desc=False)
            .execute())
        cards = resp.data or []
        for card in cards:
            if isinstance(card.get("actions"), str):
                card["actions"] = json.loads(card["actions"])
        ai_cards = [c for c in cards if c.get("source") == "ai"]
        generated_at = ai_cards[0].get("generated_at") if ai_cards else None
        return {"cards": cards, "count": len(cards),
                "generated_at": generated_at, "fresh": cards_are_fresh(user_id)}
    except UserNotFoundException:
        raise HTTPException(status_code=404, detail="User not found")
    except Exception as e:
        logger.exception(f"Failed to get cards for {user_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve advisor cards")


@router.post("/generate/{user_id}", response_model=dict)
async def generate_cards(user_id: str, request: GenerateRequest):
    try:
        get_user_by_id(user_id)
        if not request.force and cards_are_fresh(user_id):
            return await get_cards(user_id)

        ctx = fetch_student_context(user_id)
        saved = fetch_saved_cards(user_id)
        prompt = build_rich_context(ctx, saved_cards=saved) + _lang_instruction(request.language)

        # FIX: Use module-level singleton instead of creating a new client per request.
        # FIX: Use settings.CLAUDE_MODEL so model is configurable without code changes.
        client = get_anthropic_client()
        message = client.messages.create(
            model=settings.CLAUDE_MODEL,
            max_tokens=4096,
            messages=[{"role": "user", "content": prompt}],
        )

        raw = message.content[0].text.strip()
        if raw.startswith("```"):
            raw = raw.split("\n", 1)[1].rsplit("```", 1)[0].strip()

        cards = json.loads(raw)
        if not isinstance(cards, list):
            raise ValueError("AI did not return a JSON array")

        for card in cards:
            card["category"] = _sanitise_category(card)
            card.setdefault("type", "insight")
            card.setdefault("icon", "ðŸ’¡")
            card.setdefault("actions", [])

        save_cards(user_id, cards)
        logger.info(f"Generated {len(cards)} cards for {user_id}")
        return await get_cards(user_id)

    except UserNotFoundException:
        raise HTTPException(status_code=404, detail="User not found")
    except json.JSONDecodeError as e:
        logger.error(f"Card JSON parse error: {e}")
        raise HTTPException(status_code=500, detail="Failed to parse AI response")
    except Exception as e:
        logger.exception(f"Card generation failed for {user_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to generate advisor cards")


@router.post("/retranslate/{user_id}", response_model=dict)
async def retranslate_cards(user_id: str, request: RetranslateRequest):
    """Re-generate all non-saved user-asked cards in the new language."""
    try:
        get_user_by_id(user_id)
        supabase = get_supabase()

        # Fetch all non-saved user-asked cards that have a stored question
        resp = (supabase.table("advisor_cards")
            .select("id, user_question")
            .eq("user_id", user_id)
            .eq("source", "user")
            .eq("is_saved", False)
            .execute())
        user_cards = [c for c in (resp.data or []) if c.get("user_question")]

        if not user_cards:
            return {"retranslated": 0}

        ctx = fetch_student_context(user_id)
        client = get_anthropic_client()
        retranslated = 0

        for card_row in user_cards:
            card_id = card_row["id"]
            question = card_row["user_question"]

            prompt = f"""You are a proactive AI academic advisor for McGill University.
A student has asked: "{question}"

Based on their profile below, generate a single helpful advisor card that directly answers their question.

{build_rich_context(ctx)}

Return a single JSON object (not an array) with these fields:
  "type"     : one of "urgent" | "warning" | "insight" | "progress"
  "icon"     : single emoji relevant to the answer
  "label"    : short ALL-CAPS label (â‰¤ 4 words)
  "title"    : concise headline answering the question (â‰¤ 12 words)
  "body"     : 2â€“4 sentence answer with specific, actionable detail
  "actions"  : array of 2â€“3 follow-up question strings
  "category" : one of: {", ".join(f'"{c}"' for c in CARD_CATEGORIES)}

Return ONLY the JSON object â€” no markdown, no commentary.{_lang_instruction(request.language)}"""

            try:
                message = client.messages.create(
                    model=settings.CLAUDE_MODEL,
                    max_tokens=1024,
                    messages=[{"role": "user", "content": prompt}],
                )
                raw = message.content[0].text.strip()
                if raw.startswith("```"):
                    raw = raw.split("\n", 1)[1].rsplit("```", 1)[0].strip()
                card_data = json.loads(raw)

                # Update the existing card in-place
                supabase.table("advisor_cards").update({
                    "card_type": card_data.get("type", "insight"),
                    "icon": card_data.get("icon", "ðŸ’¬"),
                    "label": card_data.get("label", ""),
                    "title": card_data.get("title", ""),
                    "body": card_data.get("body", ""),
                    "actions": json.dumps(card_data.get("actions", [])),
                    "category": _sanitise_category(card_data),
                    "generated_at": datetime.now(timezone.utc).isoformat(),
                }).eq("id", card_id).execute()
                retranslated += 1

            except Exception as e:
                logger.warning(f"Failed to retranslate card {card_id}: {e}")
                continue

        logger.info(f"Retranslated {retranslated} user cards for {user_id} to '{request.language}'")
        return {"retranslated": retranslated}

    except UserNotFoundException:
        raise HTTPException(status_code=404, detail="User not found")
    except Exception as e:
        logger.exception(f"Retranslate failed for {user_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to retranslate cards")


@router.delete("/{user_id}", status_code=204)
async def clear_cards(user_id: str):
    try:
        get_user_by_id(user_id)
        supabase = get_supabase()
        # Only delete non-saved AI cards
        supabase.table("advisor_cards").delete() \
            .eq("user_id", user_id) \
            .eq("source", "ai") \
            .eq("is_saved", False) \
            .execute()
    except UserNotFoundException:
        raise HTTPException(status_code=404, detail="User not found")
    except Exception as e:
        logger.exception(f"Failed to clear cards for {user_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to clear cards")


@router.delete("/{user_id}/{card_id}", status_code=204)
async def delete_card(user_id: str, card_id: str):
    """Permanently delete a single advisor card for a user."""
    try:
        get_user_by_id(user_id)
        supabase = get_supabase()
        supabase.table("advisor_cards").delete() \
            .eq("id", card_id) \
            .eq("user_id", user_id) \
            .execute()
    except UserNotFoundException:
        raise HTTPException(status_code=404, detail="User not found")
    except Exception as e:
        logger.exception(f"Failed to delete card {card_id} for {user_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to delete card")


@router.post("/ask/{user_id}", response_model=dict)
async def ask_card(user_id: str, request: AskRequest):
    try:
        get_user_by_id(user_id)
        ctx = fetch_student_context(user_id)

        prompt = f"""You are a proactive AI academic advisor for McGill University.
A student has asked: "{request.question}"

Based on their profile below, generate a single helpful advisor card that directly answers their question.

{build_rich_context(ctx)}

Return a single JSON object (not an array) with these fields:
  "type"     : one of "urgent" | "warning" | "insight" | "progress"
  "icon"     : single emoji relevant to the answer
  "label"    : short ALL-CAPS label (â‰¤ 4 words)
  "title"    : concise headline answering the question (â‰¤ 12 words)
  "body"     : 2â€“4 sentence answer with specific, actionable detail
  "actions"  : array of 2â€“3 follow-up question strings
  "category" : one of: {", ".join(f'"{c}"' for c in CARD_CATEGORIES)}

Return ONLY the JSON object â€” no markdown, no commentary.{_lang_instruction(request.language)}"""

        # FIX: Use module-level singleton instead of creating a new client per request.
        client = get_anthropic_client()
        message = client.messages.create(
            model=settings.CLAUDE_MODEL,
            max_tokens=1024,
            messages=[{"role": "user", "content": prompt}],
        )

        raw = message.content[0].text.strip()
        if raw.startswith("```"):
            raw = raw.split("\n", 1)[1].rsplit("```", 1)[0].strip()

        card_data = json.loads(raw)
        card = insert_user_card(user_id, card_data, request.question)
        return {"card": card}

    except UserNotFoundException:
        raise HTTPException(status_code=404, detail="User not found")
    except json.JSONDecodeError as e:
        logger.error(f"Ask card JSON parse error: {e}")
        raise HTTPException(status_code=500, detail="Failed to parse AI response")
    except Exception as e:
        logger.exception(f"Ask card failed for {user_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to generate card from question")


@router.post("/{card_id}/thread", response_model=dict)
async def thread_message(card_id: str, request: ThreadRequest):
    try:
        prompt = f"""You are a helpful AI academic advisor for McGill University.
The student is asking a follow-up question about this advisor card:

Card context: {request.card_context}

Student's follow-up: {request.message}

Provide a concise, helpful, and specific response (2â€“4 sentences). Be direct and actionable.{_lang_instruction(request.language)}"""

        # FIX: Use module-level singleton instead of creating a new client per request.
        client = get_anthropic_client()
        message = client.messages.create(
            model=settings.CLAUDE_MODEL,
            max_tokens=512,
            messages=[{"role": "user", "content": prompt}],
        )

        return {"response": message.content[0].text.strip()}

    except Exception as e:
        logger.exception(f"Thread message failed for card {card_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to process thread message")


@router.patch("/{card_id}/save", response_model=dict)
async def save_card(card_id: str, request: SaveRequest):
    try:
        supabase = get_supabase()
        result = supabase.table("advisor_cards") \
            .update({"is_saved": request.is_saved}) \
            .eq("id", card_id) \
            .execute()
        if not result.data:
            raise HTTPException(status_code=404, detail="Card not found")
        card = result.data[0]
        if isinstance(card.get("actions"), str):
            card["actions"] = json.loads(card["actions"])
        return card
    except HTTPException:
        raise
    except Exception as e:
        logger.exception(f"Failed to save card {card_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to update card")


@router.patch("/{user_id}/reorder", response_model=dict)
async def reorder_cards(user_id: str, request: ReorderRequest):
    try:
        # 1. Validation check
        get_user_by_id(user_id)
        
        # 2. Get client
        supabase = get_supabase()
        
        # 3. Call the RPC function
        # We pass the 'order' list directly from the request
        supabase.rpc("reorder_advisor_cards", {"payload": request.order}).execute()
        
        logger.info(f"Successfully reordered {len(request.order)} cards for user {user_id}")
        return {"reordered": len(request.order)}
        
    except UserNotFoundException:
        raise HTTPException(status_code=404, detail="User not found")
    except Exception as e:
        logger.exception(f"Failed to reorder cards for {user_id}: {e}")
        raise HTTPException(status_code=500, detail="Failed to reorder cards")
